---
layout: post
title: 五、GstMemory
categories: GStreamer核心对象
tags: [GStreamer]
---

## 1 GstMemory基本概念

- `GstMemory` 是一个轻量级的引用计数对象（继承于GstMiniObject），用于包装内存区域。
- `GstBuffer` 的就是由多个 `GstMemory` 构成。一个 GstMemory 对象有一个分配的内存区域，最大大小为 maxsize。在内存对象的生命周期内，最大大小不会改变。内存还有一个偏移量和大小属性，用于指定分配区域内有效的内存范围。
- `GstMemory` 通常由分配器通过 gst_allocator_alloc 方法调用创建。当使用 NULL 作为分配器时，将使用默认分配器。可以通过 gst_allocator_register 注册新的分配器。分配器通过名称标识，并可以通过 gst_allocator_find 检索。可以使用 gst_allocator_set_default 来更改默认分配器。
- 可以使用 gst_memory_new_wrapped 创建新的内存，它包装在其他地方分配的内存。
- 对内存块的引用计数是通过 gst_memory_ref 和 gst_memory_unref 来执行的。
- 可以分别使用 gst_memory_get_sizes 和 gst_memory_resize 来检索和更改内存的大小。
- 获取对内存数据的访问是通过 gst_memory_map 来执行的。调用将返回一个指向内存区域中偏移量字节的指针。在完成内存访问后，应该调用 gst_memory_unmap。
- 可以通过 gst_memory_copy 来复制内存，这将返回一个可写的副本。gst_memory_share 将创建一个新的内存块，它在自定义偏移量和自定义大小下与现有内存块共享内存。
- 当 gst_memory_is_span 返回 TRUE 时，可以有效地合并内存。

### 1.1 GstMapInfo结构体
```c
/* filename: gstmemory.h */
/**
 * GstMapInfo:
 * @memory: 映射内存的指针
 * @flags: 映射内存时使用的标志
 * @data: (array length=size): 映射数据的指针
 * @size: 在 @data 中的有效大小
 * @maxsize: 在 @data 中的最大字节数
 * @user_data: 内存实现可以使用的额外私有用户数据，用于存储额外信息。
 *
 * 一个包含映射操作结果的结构，例如 gst_memory_map()。它包含了数据和大小。
 *
 * #GstMapInfo 不能与 g_auto() 一起使用，因为不确定它是否需要使用 gst_buffer_unmap() 或 gst_memory_unmap() 来解映射。相反，可以在这种情况下使用 #GstBufferMapInfo 和 #GstMemoryMapInfo。
 */
 typedef struct {
  GstMemory *memory;
  GstMapFlags flags;
  guint8 *data;
  gsize size;
  gsize maxsize;
  /*< protected >*/
  gpointer user_data[4];

  /*< private >*/
  gpointer _gst_reserved[GST_PADDING];
} GstMapInfo;
```

## 2 GstMemory类型结构

### 2.1 GstMemory类型注册宏定义

```c
/* filename: gstmemory.h */
GST_API GType _gst_memory_type;
#define GST_TYPE_MEMORY (_gst_memory_type)

GST_API
GType gst_memory_get_type(void);

/* filename: gstmemory.c */
GType _gst_memory_type = 0;
GST_DEFINE_MINI_OBJECT_TYPE (GstMemory, gst_memory);

/* gst_init调用该函数 */
void
_priv_gst_memory_initialize (void)
{
  _gst_memory_type = gst_memory_get_type ();
}
```

### 2.2 GstMemory类型相关枚举定义

#### 2.2.1 GstMemoryFlags
```c
/* filename: gstmemory.h */
/**
 * GstMemoryFlags:
 * @GST_MEMORY_FLAG_READONLY: 内存是只读的。不允许使用 #GST_MAP_WRITE 映射内存。
 * @GST_MEMORY_FLAG_NO_SHARE: 内存不得共享。当需要在缓冲区之间共享此内存时，必须制作副本。（已弃用：
 * 在新代码中不要使用，你应该为内存池创建一个自定义的 GstAllocator，而不是依赖于它们最初附加到的 GstBuffer。）
 * @GST_MEMORY_FLAG_ZERO_PREFIXED: 内存前缀被填充为 0 字节
 * @GST_MEMORY_FLAG_ZERO_PADDED: 内存填充被填充为 0 字节
 * @GST_MEMORY_FLAG_PHYSICALLY_CONTIGUOUS: 内存在物理上是连续的。（自版本 1.2 起）
 * @GST_MEMORY_FLAG_NOT_MAPPABLE: 内存不能通过 gst_memory_map() 映射，无需任何前提条件。（自版本 1.2 起）
 * @GST_MEMORY_FLAG_LAST: 可用于自定义目的的第一个标志
 *
 * 包装内存的标志。
 */
typedef enum {
  GST_MEMORY_FLAG_READONLY      = GST_MINI_OBJECT_FLAG_LOCK_READONLY,
  GST_MEMORY_FLAG_NO_SHARE      = (GST_MINI_OBJECT_FLAG_LAST << 0),
  GST_MEMORY_FLAG_ZERO_PREFIXED = (GST_MINI_OBJECT_FLAG_LAST << 1),
  GST_MEMORY_FLAG_ZERO_PADDED   = (GST_MINI_OBJECT_FLAG_LAST << 2),
  GST_MEMORY_FLAG_PHYSICALLY_CONTIGUOUS = (GST_MINI_OBJECT_FLAG_LAST << 3),
  GST_MEMORY_FLAG_NOT_MAPPABLE  = (GST_MINI_OBJECT_FLAG_LAST << 4),

  GST_MEMORY_FLAG_LAST          = (GST_MINI_OBJECT_FLAG_LAST << 16)
} GstMemoryFlags;
```

#### 2.2.2 GstMapFlags
```c
/* filename: gstmemory.h */
/**
 * GstMapFlags:
 * @GST_MAP_READ: 用于读取访问的映射
 * @GST_MAP_WRITE: 用于写入访问的映射
 * @GST_MAP_FLAG_LAST: 可用于自定义目的的第一个标志
 *
 * 映射内存时使用的标志
 */

typedef enum {
  GST_MAP_READ      = GST_LOCK_FLAG_READ,
  GST_MAP_WRITE     = GST_LOCK_FLAG_WRITE,

  GST_MAP_FLAG_LAST = (1 << 16)
} GstMapFlags;
```

### 2.3 GstMemory结构体

```c
/**
 * GstMemory:
 * @mini_object: 父结构
 * @allocator: 指向 #GstAllocator 的指针
 * @parent: 父内存块
 * @maxsize: 分配的最大大小
 * @align: 内存的对齐方式
 * @offset: 有效数据开始的偏移量
 * @size: 有效数据的大小
 *
 * 用于内存实现的基础结构。自定义内存将把此结构作为它们结构的第一个成员。
 */
struct _GstMemory {
  GstMiniObject   mini_object;

  GstAllocator   *allocator;

  GstMemory      *parent;
  gsize           maxsize;
  gsize           align;
  gsize           offset;
  gsize           size;
};
```