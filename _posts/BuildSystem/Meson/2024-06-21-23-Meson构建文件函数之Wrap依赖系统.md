---
layout: post
title: 三、Wrap依赖系统
categories: Meson
tags: [Meson]
---

多平台开发的主要问题之一是管理所有的依赖项。这在许多平台上都很尴尬，尤其是在那些没有内置包管理器的平台上。后者的问题已经通过使用第三方包管理器来解决。它们并不是真正的解决方案，因为你不能告诉用户安装一个包管理器来使用你的应用。在这些平台上，你必须生产自给自足的应用程序。当目标平台缺少（更新版本的）应用程序的依赖项时，也适用同样的原则。

传统的方法是将依赖项打包在你自己的项目内。要么作为预构建的库和头文件，要么通过在源代码树中嵌入源代码并重写构建系统，使其成为项目的一部分。

这既繁琐又容易出错，因为它总是手动完成的。Meson的Wrap依赖系统旨在提供一种自动化的方式来做到这一点。

## 1 wrap的工作原理

Meson有子项目的概念。它们是在另一个Meson项目内嵌套一个Meson项目的方式。任何使用Meson构建的项目都可以检测到它是作为一个子项目构建的，并以一种易于使用的方式构建自己（通常意味着作为一个静态库）。

要将这种项目作为依赖项使用，你可以只需复制并提取它到你项目的subprojects目录中。

然而，还有一个更简单的方法。你可以指定一个Wrap文件，告诉Meson如何为你下载它。如果你在构建中使用了这个子项目，Meson将在构建期间自动下载并提取它。这使得嵌入子项目变得极为简单。

所有wrap文件必须以 `<project_name>.wrap` 的形式命名，并位于subprojects目录中。

目前Meson有四种类型的wraps：

```
wrap-file
wrap-git
wrap-hg
wrap-svn
```
## 2 wrap格式

Wrap文件以ini格式编写，包含一个包含wrap类型的单一头部，然后是描述如何获取源代码、验证它们，并在需要时修改它们的属性。一个名为libfoobar的wrap-file的例子会有一个文件名libfoobar.wrap，看起来像这样：

```python
[wrap-file]
directory = libfoobar-1.0

source_url = https://example.com/foobar-1.0.tar.gz
source_filename = foobar-1.0.tar.gz
source_hash = 5ebeea0dfb75d090ea0e7ff84799b2a7a1550db3fe61eb5f6f61c2e971e57663
```

一个`wrap-git`文件的示例如下：

```python
[wrap-git]
url = https://github.com/libfoobar/libfoobar.git
revision = head
depth = 1
```

## 3 Wrap文件可接受配置属性

- directory - 子项目根目录的名称，默认为 wrap 的名称。

- patch_url - 下载可选覆盖存档的 URL

- patch_fallback_url - 当从 patch_url 下载失败时使用的备用 URL

- patch_filename - 下载的覆盖存档的文件名

- patch_hash - 下载的覆盖存档的 sha256 校验和

- patch_directory - 覆盖目录，本地文件的替代方案，放置在 subprojects/packagefiles 目录中

- diff_files - 本地 diff 文件的逗号分隔列表

- method - 子项目使用的构建系统，默认为 meson

### 3.1 wrap-file 专用属性

- source_url - 下载 wrap 文件源存档的 URL

- source_fallback_url - 当从 source_url 下载失败时使用的备用 URL

- source_filename - 下载的源存档的文件名

- source_hash - 下载的源存档的 sha256 校验和

- lead_directory_missing - wrap-file 创建前导目录名称。当源文件没有前导目录时需要。

### 3.2 VCS-based wraps 专用属性

- url - 要克隆的 wrap-git 仓库的名称

- revision - 要检出的修订版本

### 3.3 wrap-git 专用属性

- depth - 浅克隆仓库的提交数量

- push-url - 配置为 git push-url 的备用 URL

- clone-recursive - 同时克隆仓库的子模块

## 4 provide

