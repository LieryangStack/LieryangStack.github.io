---
layout: post
title: 二、QML——Item
categories: QML
tags: [QML]
---

## 1 Item

- Item类型是所有可视化类型的基类，Item类型是在QtQuick中。

- QtQuick中所有可视项都继承自Item。尽管Item对象没有视觉外观，但他定义了所有视觉类型的基本属性，比如x,y位置，宽高以及锚点等。

- Item类型可以作为根元素包含视觉项目。


  ```qml
  import QtQuick 2.0

  Item {
      Image {
          source: "tile.png"
      }
      Image {
          x: 80
          width: 100
          height: 100
          source: "tile.png"
      }
      Image {
          x: 190
          width: 100
          height: 100
          fillMode: Image.Tile
          source: "tile.png"
      }
  }
  ```

## 2 QQmlEngine

QQmlEngine类为实例化QML组件提供了环境。

每个QML组件都在 `QQmlContext` 中实例化。在QML中，上下文是按层次排列的，这次层次由QQmlEngine管理。

在创建任何 QML 组件之前，应用程序必须创建一个 QQmlEngine 才能访问 QML 上下文。

## 3 QQmlComponent

组件是可重用的、封装的 QML 类型，具有定义良好的接口。

可以从 QML 文件创建一个 QQmlComponent 实例。例如，如果有一个 main.qml 文件，如下所示：

```qml
import QtQuick 2.0

Item {
    width: 200
    height: 200
}
```

以下代码将该 QML 文件加载为一个组件，使用 create() 创建该组件的实例，然后查询 Item 的宽度值：

```c++
QQmlEngine *engine = new QQmlEngine;
QQmlComponent component(engine, QUrl::fromLocalFile("main.qml"));

QObject *myObject = component.create();
QQuickItem *item = qobject_cast<QQuickItem*>(myObject);
int width = item->width();  // width = 200
```

```c++
void MyCppItem::init()
{
    QQmlEngine *engine = qmlEngine(this);
    // 或者：
    // QQmlEngine *engine = qmlContext(this)->engine();
    QQmlComponent component(engine, QUrl::fromLocalFile("MyItem.qml"));
    QQuickItem *childItem = qobject_cast<QQuickItem*>(component.create());
    childItem->setParentItem(this);
}
```

请注意，当这些函数在 QObject 子类的构造函数中调用时，将返回 null，因为此时实例尚未拥有上下文或引擎。

## 4 QQmlApplicationEngine

此类结合了 QQmlEngine 和 QQmlComponent，提供了一种方便的方法来加载单个 QML 文件。它还向 QML 暴露了一些核心应用程序功能，通常在 C++/QML 混合应用程序中由 C++ 控制。

可以这样使用：

```c++
#include <QGuiApplication>
#include <QQmlApplicationEngine>

int main(int argc, char *argv[])
{
    QGuiApplication app(argc, argv);
    QQmlApplicationEngine engine("main.qml");
    return app.exec();
}
```

与 QQuickView 不同，QQmlApplicationEngine 不会自动创建根窗口。如果你使用的是 Qt Quick 中的可视元素，你需要将它们放在一个 Window 内。

如果你没有使用需要 QGuiApplication 的 QML 模块（如 QtQuick），你也可以将 QCoreApplication 与 QQmlApplicationEngine 一起使用。

QQmlEngine 默认配置的更改列表：

- 将 Qt.quit() 连接到 QCoreApplication::quit()。

- 自动加载与主 QML 文件相邻的 i18n 目录中的翻译文件。翻译文件必须有 "qml_" 前缀，例如 qml_ja_JP.qm。

- 当 QJSEngine::uiLanguage / Qt.uiLanguage 属性更改时，翻译文件会重新加载。

- 如果场景包含 QQuickWindow，则自动设置一个孵化控制器（incubation controller）。

- 自动将 QQmlFileSelector 作为 URL 拦截器，应用文件选择器到所有 QML 文件和资源。

可以通过使用继承自 QQmlEngine 的方法进一步调整引擎行为。

## 5 Item属性

### 5.1 clip

该属性表示是否启用了裁剪。默认的 `clip` 值为 `false`

如果启用裁剪，项目item将会裁剪自身的绘制内容，以及子项的绘制内容，使其限制在边界矩形内。

代码参考：[/assets/Qt6/qml_13_Flicked/01_DisplayLargeImg.qml](/assets/Qt6/qml_13_Flicked/01_DisplayLargeImg.qml)

![alt text](/assets/Qt6/qml_02_Item/image/image.png)

### 5.2 containmentMask

该属性表示用于 `contains()` 方法的可选遮罩mask。它的主要用途是确定pointer event（如鼠标、触控板或触摸屏）相关的操作事件是否落入`item`中。

`Item` 是通过 `contains()` 函数来判断是否处于区域内的，但是其默认只判断了矩形范围，并没有对圆角或者图形裁剪等做判断。


1. 通过一个 `Item` 指定其范围指定 `contains()` 响应。比如：写一个`Rectangle`，进入另一个`Rectangle`，就会触发。例子参考：[/assets/Qt6/qml_02_Item/containmentMask_Rect.qml](/assets/Qt6/qml_02_Item/containmentMask_Rect.qml)

    ![alt text](/assets/Qt6/qml_02_Item/image/image-1.png)

2. 通过一个 `Shape` 路径指定 `contains()` 响应。
   
    ![alt text](/assets/Qt6/qml_02_Item/image/image-3.png)

3. 通过编写 `contains()` 函数。返回TRUE，表示在范围内。
    
    ![alt text](/assets/Qt6/qml_02_Item/image/image-2.png)



默认情况下，`contains()` 方法对于项目边界框内(比如规则矩形)的任何点都会返回 true。`containmentMask` 允许更细粒度的控制。例如，如果使用自定义的 `C++ QQuickItem` 子类，具有专门的 `contains()` 方法作为 `containmentMask`：


