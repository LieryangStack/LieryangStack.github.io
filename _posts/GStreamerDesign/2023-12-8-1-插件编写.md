---
layout: post
title: 一、插件编写
categories: GStreamer设计
tags: [GStreamer]
---

## 激活

改变状态时，一个 <span style="color:red;">bin 会按照从sink到source的顺序</span>为其所有子元素设置状态。当元素经历 READY→PAUSED 过渡时，它们的Pad会被激活以准备数据流。一些Pad会启动任务以驱动数据流。

<span style="color:red;">一个元素会从sourcepads到sinkpads依次激活其Pad。</span>这是为了确保当sinkpads被激活并准备接收数据时，sourcepads已经激活以向下游传递数据。

Pads可以在 PUSH 和 PULL 两种模式下激活。PUSH 模式是正常情况，其中链接中的source pad通过 gst_pad_push() 将数据发送到对端的sink pad。而 PULL 模式则是由source pad请求数据通过 gst_pad_pull_range()。

要激活一个Pad，核心会以 TRUE 参数调用 gst_pad_set_active()，表示该Pad应该处于激活状态。如果Pad已经处于激活状态，无论是在 PUSH 还是 PULL 模式下，gst_pad_set_active() 将不执行任何操作而直接返回。否则将调用Pad的激活函数。

因为核心不知道以那种模式激活一个端口（PUSH 还是 PULL），它将这个选择委托给了端口的 activate() 方法。一个端口的 activate() 函数应该选择在 PUSH 或 PULL 模式下操作。一旦做出选择，它应该使用所选的激活模式调用 activate_mode()。默认的 activate() 函数会使用 #GST_PAD_MODE_PUSH 调用 activate_mode()，因为这是数据流的默认机制。如果支持两种操作模式的sinkpad，在上游进行 SCHEDULING 查询包含 #GST_PAD_MODE_PULL 调度模式时，可能会调用 activate_mode(PULL)，否则调用 activate_mode(PUSH)。

考虑 fakesrc ! fakesink 的情况，其中 fakesink 配置为以 PULL 模式运行。pipeline中的状态变化将从 fakesink 开始，它是最下游的元素。核心将在 fakesink 的sinkpad上调用 activate()。为了让 fakesink 进入 PULL 模式，它需要实现一个自定义的 activate() 函数，该函数将在其sinkpad上调用 activate_mode(PULL)（因为默认情况下使用的是 PUSH 模式）。然后 activate_mode(PULL) 负责启动从 fakesrc:src 拉取数据的任务。显然，即使pipeline尚未改变 fakesrc 的状态，fakesrc 也需要被通知即将在其src pad上拉取数据。因此，GStreamer 将首先在 fakesink:sink 的对等Pad上调用 activate_mode(PULL)，然后才在 fakesink:sinks 上调用 activate_mode(PULL)。

简而言之，在 PULL 模式下运行的上游元素必须在 READY 中准备好产生数据，在其src pad上调用 activate_mode(PULL) 之后。此外，对 activate_mode(PULL) 的调用需要传播到每个 gst_pad_pull() 能到达的Pad。在 fakesrc ! identity ! fakesink 的情况下，对 identity 的src pad调用 activate_mode(PULL) 将需要激活其sink pad进入 PULL 模式，这应该传播到 fakesrc。

另一方面，如果 fakesrc ! fakesink 以 PUSH 模式运行，则激活顺序不同。首先，在 fakesink:sink 上调用 activate() 将在 fakesink:sink 上调用 activate_mode(PUSH)。然后激活 fakesrc 的端口：先src pad，然后是sink pad（fakesrc 没有sink pad）。然后调用 fakesrc:src 的激活函数。

请注意，设置源端口的激活函数是没有意义的。源端口的对等端口在下游，意味着它应该首先被激活。如果它以 PULL 模式激活，源端口应该已经对其进行了 activate_mode(PULL) 调用，因此不需要进一步激活。否则它应该处于 PUSH 模式，这是默认激活函数的选择。

所以，在 PUSH 模式下，默认激活函数选择 PUSH 模式，调用 activate_mode(PUSH)，然后开始在源端口上启动任务并开始推送。这样 PUSH 调度会更加简单，因为它遵循管线中状态变化的顺序。fakesink 在 fakesrc 开始推送数据时已经处于 PAUSED 状态，并具有活跃的sink pad。

## 取消激活（停用）

端口的停用发生在其父级进入 READY 状态时，或者当应用程序或元素明确地停用端口时。调用 gst_pad_set_active() 并使用 FALSE 参数，然后根据端口的当前激活模式调用 activate_mode(PUSH) 或 activate_mode(PULL) 并使用 FALSE 参数。


